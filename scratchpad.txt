// generate board (max size 26x26)
// generate bag of tiles (72, 6 colors, 6 types, 2 of each combo)
// shuffle tile order in the bag with remove(randInt) and addFront().
// each player draws 6 tiles from the bag [auto]

// Loop start

// player 1 goes first
// player 1 selects a tile
// player 1 places a tile
// player 1 draws a tile [auto]
// player 1 score for action is calculated and added to playerScore, check for 
// qwirkle

// player 2 turn, as per player 1 sequence

// game ends when all tiles are placed

#include "GameLogic.h"

GameLogic::GameLogic()
{
    Board* board = new Board;
    LinkedList* tileBag = new LinkedList;
}

GameLogic::~GameLogic(){
    delete board;
    delete tileBag;
}

void GameLogic::gameLoop(){
    fillBag();
}

void GameLogic::fillBag(){
    // Filling the bag with 72 tiles
    char colorsArray[NUM_COLOURS] {RED,ORANGE,YELLOW,GREEN,BLUE,PURPLE};
    for (int colour = 0; colour < NUM_COLOURS; colour++)
    {
        for (int shape = 0; shape < NUM_SHAPES; shape++)
        {
            Tile* tile = new Tile(colorsArray[colour], shape);
            // Will just call the add method twice instead of putting in a loop
            tileBag->addFront(tile);
            tileBag->addFront(tile);
        }
    }
    // shuffle the contents around
    for (size_t i = 0; i < 256; i++)
    {
        int rando = rand() % 71;
        tileBag->addFront(tileBag->get(rando));
        tileBag->remove(rando+1);
    }
}

void GameLogic::placeTile(){
    // Get tile from player hand
    // Check if location is valid
    // execute move
}

void GameLogic::placementValidation(){
    // get location
    // check NSEW directions for tiles
    
    // a tile can only be placed next to a tile that matches the colour or shape
    // of a neighbor. A tile also can't be a repeat in a "set".

    // if a direction has a tile, check the shape, then the color.(4 submethods)
    // If there is a match, look for matches in that direction.(4 submethods)
    // to determine what that direction 'line' is, shape or color.
    // Could use a linked list?, make the list then iterate through it with some
    // test cases depending on the new tile.

    // if TILE in DIRECTION then SEARCH TILES until 5 or null.
    // if TILE is already in SEARCH LIST then negative
    // if TILE does not match SEARCH LIST COLOUR then negative
    // if TILE does not match SEARCH LIST SHAPE then negative
    
}